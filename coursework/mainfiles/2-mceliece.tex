%!TEX root = ../coursework.tex

\section{Обзор криптосистемы Мак‑Элиса}

Криптосистема Мак‑Элиса (McEliece, 1978) — классическая кодовая схема с открытым ключом, чья стойкость опирается на сложность декодирования линейного кода при ограничении на вес ошибки (bounded‑distance decoding). В консервативном варианте используются двоичные коды Гоппы над полем \(\mathbb{F}_{2^m}\) \cite{ClassicMcEliece2020}.

\paragraph{Параметры и ключи.}
Пусть \(C\subseteq\{0,1\}^n\) — линейный код параметров \([n,k,d]\) с эффективным декодером до \(t=\lfloor(d-1)/2\rfloor\) ошибок (для кодов Гоппы — алгоритм Паттерсона).
Секретный ключ — тройка \((S,G,P)\): \(G\in\{0,1\}^{k\times n}\) — порождающая матрица кода \(C\); \(S\in \mathrm{GL}_k(\mathbb{F}_2)\) — случайная невырожденная матрица (маскирует базис); \(P\in\{0,1\}^{n\times n}\) — перестановочная матрица (маскирует позиции). Открытый ключ: \(G' = SGP\).

\paragraph{Шифрование (вариант McEliece–PKE).}
Для сообщения \(m\in\{0,1\}^k\) выбирают фиксированного веса (\(\mathrm{wt}(e)=t\)) случайный вектор ошибки \(e\in\{0,1\}^n\) и вычисляют
\[
  c = mG' \oplus e \in \{0,1\}^n .
\]

\paragraph{Расшифрование.}
Получатель умножает \(c\) справа на \(P^{-1}\):
\[
  cP^{-1} = mSG \oplus eP^{-1}.
\]
Поскольку \(SG\) — порождающая матрица исходного кода \(C\), декодер исправляет ошибки веса \(\le t\) и восстанавливает \(mS\); затем умножение слева на \(S^{-1}\) даёт исходное \(m\).

\paragraph{Эквивалентная форма Нидеррайтера (используется в Classic McEliece–KEM).}
Вместо \(G'\) публикуют замаскированную проверочную матрицу \(H' = RHP\) размера \((n-k)\times n\), где \(H\) — проверочная матрица кода \(C\), \(R\in \mathrm{GL}_{n-k}(\mathbb{F}_2)\) и \(P\) — перестановка (обратите внимание: \(R\) \emph{не} совпадает с \(S\) выше).
Шифротекст — синдром \(s = H' e^{\top}\) для случайного \(e\) веса \(t\).
Дешифрование сводится к синдрому‑декодированию в структуре кода Гоппы у держателя секрета.
В спецификации Classic McEliece поверх этого строится IND-CCA2-безопасный KEM~\cite{ClassicMcEliece2020}.
Под \emph{IND-CCA2-безопасностью} понимается стойкость схемы в модели неразличимости шифртекстов при адаптивных атаках с выбором расшифровок
(\emph{Indistinguishability under Adaptive Chosen-Ciphertext Attack}):
злоумышленник не может отличить инкапсулированный ключ от случайного, даже имея доступ к оракулу деккапсуляции,
за исключением запрета расшифровывать сам целевой шифртекст.
Такой уровень стойкости считается наивысшим практическим стандартом для KEM-схем.

\paragraph{Безопасность.}
Базовая трудность — задача синдромного декодирования: по \(H\), синдрому \(s\) и целевому весу \(t\) найти \(e\) минимального (или заданного) веса из уравнения \(He^{\top}=s^{\top}\). В общем случае она NP‑трудна \cite{BMT1978}; на практике лучшие атаки — семейство ISD‑алгоритмов (Prange, Stern, Dumer, MMT, BJMM и множественные усовершенствования) \cite{Shintaro2024}. Их временная сложность экспоненциальна по параметрам (точнее, по избыточности \(n-k\) и профилю веса).

Показательно, что рекордные успешные декодирования касаются \emph{умеренных} параметров (например, \(n\approx 1400\) и малые \(t\)), решаемых усовершенствованными BJMM/ММТ‑подобными методами на кластерах/GPU в практические сроки \cite{Shintaro2024}. Для рекомендуемых наборов Classic McEliece используются существенно более крупные коды; ориентировочно:
\begin{itemize}
  \item уровень \(\sim\!128\) бит: \((n,k,t)=(3488,2720,64)\);
  \item уровень \(\sim\!256\) бит: \((n,k,t)=(8192,6528,128)\).
\end{itemize}
Оценки сложности лучших ISD‑атак для этих параметров на уровне \(2^{128}\) операций и выше; практический взлом недостижим при текущих возможностях \cite{ClassicMcEliece2020}.




% В тексте:
%\begin{table}[!htbp] % попробуйте сначала так
% или жёстко:
\begin{table}[H]     % зафиксировать "здесь" (иногда это лучший вариант)
  \centering
  \caption{Classic McEliece (KEM, IND-CCA2): параметры и размеры ключей/шифртекста по спецификации и референс-реализациям \cite{ClassicMcEliece2020,OQSClassicMcEliece}.}
  \label{tab:cmce-sizes}
  \small
  \begin{tabular}{lrrrrrrr}
    \toprule
    Набор & \(m\) & \(n\) & \(k\) & \(t\) & \(|\mathrm{pk}|\), B & \(|\mathrm{sk}|\), B & \(|\mathrm{ct}|\), B \\
    \midrule
    mceliece348864   & 12 & 3488 & 2720 &  64 &  261120 &  6492 &  96 \\
    mceliece348864f  & 12 & 3488 & 2720 &  64 &  261120 &  6492 &  96 \\
    mceliece460896   & 13 & 4608 & 3360 &  96 &  524160 & 13608 & 156 \\
    mceliece460896f  & 13 & 4608 & 3360 &  96 &  524160 & 13608 & 156 \\
    mceliece6688128  & 13 & 6688 & 5024 & 128 & 1044992 & 13932 & 208 \\
    mceliece6688128f & 13 & 6688 & 5024 & 128 & 1044992 & 13932 & 208 \\
    mceliece6960119  & 13 & 6960 & 5413 & 119 & 1047319 & 13948 & 194 \\
    mceliece6960119f & 13 & 6960 & 5413 & 119 & 1047319 & 13948 & 194 \\
    mceliece8192128  & 13 & 8192 & 6528 & 128 & 1357824 & 14120 & 208 \\
    mceliece8192128f & 13 & 8192 & 6528 & 128 & 1357824 & 14120 & 208 \\
    \bottomrule
  \end{tabular}

  \vspace{2pt}
  \par\footnotesize
  Примечания: для двоичных кодов Гоппы \(k \ge n - m t\); конкретные \(k\) заданы спецификацией наборов. Вариант «f» — ускоренная модификация с теми же размерами ключей и шифртекста \cite{ClassicMcEliece2020}.
\end{table}



\paragraph{Квантовая устойчивость.}
В настоящее время не известен квантовый алгоритм, обеспечивающий сверхполиномиальный (а тем более полиномиальный) выигрыш для общих задач синдромного и ограниченного по расстоянию декодирования линейных кодов. Наиболее общий инструмент квантового ускорения — амплитудное усиление (по сути, поиск Гровера), которое даёт не более чем квадратичное сокращение трудоёмкости переборных подзадач (с \(2^{\lambda}\) до порядка \(\,2^{\lambda/2}\)) \cite{Grover1996}.


% --- Перерисованный рисунок в TikZ ---
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[x=0.2cm,y=0.8cm]
    % Легенда
    %\node at (17,2.1) {\small иллюстрация не в масштабе};
    % «Классика»: полная длина
    \draw[fill=black!15,draw=black] (0,1.2) rectangle (20,2.0);
    \node[anchor=west] at (20.5,1.6) {\(\;2^{\lambda}\) шагов};
    % «Гровер»: половина длины
    \draw[fill=black!15,draw=black] (0,0.0) rectangle (10,0.8);
    \node[anchor=west] at (10.5,0.4) {\(\;\approx 2^{\lambda/2}\) итераций};
    % ось для наглядности
    \draw[->] (-0.2,-0.2) -- (21.5,-0.2) node[below right] {\(\text{лог. шкала по }\lambda\)};
  \end{tikzpicture}
  \caption{Схематическое сравнение трудоёмкости классического перебора и поиска Гровера \cite{Grover1996}.}
  \label{fig:grover-tikz}
\end{figure}


При переносе этого подхода на практические ISD-атаки (семейство Prange/Stern/Dumer/MMT/BJMM и их модификации) ускорение проявляется лишь на отдельных этапах — выборе информационного множества, построении и проверке списков, поиске коллизий — и уменьшает стоимость в лучшем случае на корневой фактор, не меняя экспоненциального характера атак и их зависимости от избыточности \(n-k\) и профиля веса \cite{Shintaro2024}. Имеющиеся оценки ресурсов для реалистического, отказоустойчивого (fault-tolerant) исполнения таких квантовых вариантов указывают на крайне высокие требования к числу логических кубитов и глубине схем (сотни тысяч–миллионы логических кубитов и глубины порядка \(10^{9}\)–\(10^{12}\) вентилей уже для эквивалента \(\approx 2^{64}\) классических шагов), что на текущем технологическом уровне недостижимо \cite{Shintaro2024}. Соответственно, рекомендуемые параметры Classic McEliece выбираются с учётом консервативного «квантового» сценария: ожидаемый квадратичный выигрыш компенсирован запасом параметров, и схема рассматривается как устойчивальная к известным квантовым атакам при корректной параметризации \cite{ClassicMcEliece2020}.






\paragraph{Связь с SAT/QUBO.}
Поскольку криптоатаки на McEliece/Niederreiter сводятся к поиску вектора ошибки \(e\) фиксированного веса, задача естественно формализуется как булева оптимизация: синдромные уравнения \(He^{\top}=s^{\top}\) дают систему XOR-ограничений над \(\mathbb{F}_2\), а ограничение \(\mathrm{wt}(e)=t\) задаётся кардинальными ограничениями или точными сумматорными схемами; далее формулировка переводится в CNF (SAT) или квадратичную бинарную форму (QUBO/Ising). Такая постановка позволяет сравнивать современные SAT-решатели (CDCL с поддержкой XOR) и методы квадратичной оптимизации (включая квантовые эвристики) на единой модели. Подробная редукция и экспериментальные настройки приведены в разделе~\ref{sec:sat-crypto}.


\noindent\textbf{Преобразование шифротекста к КНФ.}


Рассмотрим сообщение $\mathbf{m} = (m_0,\, m_1,\, \ldots,\, m_k), m_i \in \{0,1\}$, открытый ключ \[
\mathbf{G}^{\prime} =
\begin{pmatrix}
g_{00} & g_{01} & \cdots & \cdots & g_{0n} \\
g_{10} & g_{11} & \cdots & \cdots & g_{1n} \\
\vdots & \vdots &        &        & \vdots \\
g_{k0} & g_{k1} & \cdots & \cdots & g_{kn}
\end{pmatrix}, g_{ij} \in \{0,1\}, 
\]

вектор ошибок $\mathbf{e} = (e_0,\, e_1,\, \ldots,\, e_n), wt(e) = t, e_i \in \{0,1\}$

Тогда шифротекст
\[
\mathbf{c} \;=\; \mathbf{m}\,\mathbf{G}^{\prime} \oplus \mathbf{e}
\;=\; (c_0 \oplus e_0,\,c_1 \oplus e_1,\,\ldots,\,c_n \oplus e_n), 
\qquad
c_j \;=\; \bigoplus_{i=1}^{k} m_i\, g_{ij}\quad (j=1,\ldots,n).
\]

 
\[
c_j = m_0 \wedge g_{j0} \oplus e_0 \;\oplus\;
       m_1 \wedge g_{j1} \oplus e_1 \;\oplus\;
       \cdots \;\oplus\;
       m_k \wedge g_{jk} \oplus e_k
\]

, где g_ij - константы, ei, mi - переменные



Исходная формула (фиксируем столбец $j$):
\[
c_j \;=\; m_0 \wedge g_{j0} \;\oplus\; e_0 \;\oplus\; m_1 \wedge g_{j1} \;\oplus\; e_1 \;\oplus\; \cdots \;\oplus\; m_k \wedge g_{jk} \;\oplus\; e_k .
\]

\paragraph{Шаг 1. Введём обозначения.}
Для каждого $i=0,\ldots,k$ положим
\[
\ell_i \;:=\; (m_i \wedge g_{ji}).
\]
Тогда исходная формула переписывается как
\[
c_j \;=\; \ell_0 \;\oplus\; e_0 \;\oplus\; \ell_1 \;\oplus\; e_1 \;\oplus\; \cdots \;\oplus\; \ell_k \;\oplus\; e_k .
\]
Мы будем переводить эту формулу в КНФ методом Цейтина: вводим вспомогательные переменные и задаём для них локальные связи в КНФ так, чтобы итоговая КНФ была эквивалентна исходной формуле по выполнимости, а размер рос линейно.

\paragraph{Шаг 2. КНФ для конъюнкции $\ell_i \leftrightarrow (m_i \wedge g_{ji})$.}
Эквивалентность $\ell_i \leftrightarrow (m_i \wedge g_{ji})$ равносильна импликациям
\[
(m_i \wedge g_{ji}) \Rightarrow \ell_i, \qquad
\ell_i \Rightarrow m_i, \qquad
\ell_i \Rightarrow g_{ji}.
\]
Это даёт три клаузы для каждого $i$:
\[
(\neg m_i \lor \neg g_{ji} \lor \ell_i)
\ \land\ 
(m_i \lor \neg \ell_i)
\ \land\ 
(g_{ji} \lor \neg \ell_i),
\qquad i=0,\ldots,k.
\]

\paragraph{Шаг 3. КНФ для исключающего ИЛИ (XOR).}
Для трёх булевых переменных $z \leftrightarrow (x \oplus y)$ стандартная КНФ из четырёх клауз:
\[
\Phi(z;x,y) \;:=\;
(\neg x \lor \neg y \lor \neg z)\ \land\
(x \lor y \lor \neg z)\ \land\
(x \lor \neg y \lor z)\ \land\
(\neg x \lor y \lor z).
\]
Эта формула реализует равенство $z = x \oplus y$.

\paragraph{Шаг 4. Свёртка длинной XOR-цепочки.}
Обозначим последовательность длины $2k{+}2$:
\[
a_{2i}=\ell_i,\quad a_{2i+1}=e_i \qquad (i=0,\ldots,k),
\]
т.\,е. $(a_0,a_1,\ldots,a_{2k+1})=(\ell_0,e_0,\ell_1,e_1,\ldots,\ell_k,e_k)$.

Введём новые переменные $p_0,\ldots,p_{2k+1}$, определяя их как «накопленную чётность»:
\[
p_0 \leftrightarrow a_0, \qquad
p_r \leftrightarrow (p_{r-1} \oplus a_r)\ \ (r=1,\ldots,2k{+}1),
\qquad
c_j \leftrightarrow p_{2k+1}.
\]
Тогда $p_{2k+1}$ есть XOR всех $a_r$, а значит $c_j$ равен исходной правой части.

Перевод в КНФ:
\[
(\neg a_0 \lor p_0)\ \land\ (a_0 \lor \neg p_0)
\]
и для каждого $r=1,\ldots,2k{+}1$ добавляем блок из четырёх клауз
\[
\Phi(p_r;\,p_{r-1},a_r),
\]
а также связываем выход
\[
(\neg p_{2k+1} \lor c_j)\ \land\ (p_{2k+1} \lor \neg c_j).
\]

\paragraph{Шаг 5. Сборка итоговой КНФ.}
Объединяя Шаги 2–4, получаем КНФ, эквивалентную исходной формуле по выполнимости:
\[
\begin{aligned}
&\bigwedge_{i=0}^{k}
\Big[(\neg m_i \lor \neg g_{ji} \lor \ell_i)\ \land\ (m_i \lor \neg \ell_i)\ \land\ (g_{ji} \lor \neg \ell_i)\Big] \\[1mm]
&\land\ (\neg a_0 \lor p_0)\ \land\ (a_0 \lor \neg p_0) \quad\text{где } a_0=\ell_0 \\[1mm]
&\land\ \bigwedge_{r=1}^{2k+1}\ \Phi(p_r;\,p_{r-1},a_r)
\quad\text{(где } a_{2i}=\ell_i,\ a_{2i+1}=e_i\text{)}\\[1mm]
&\land\ (\neg p_{2k+1} \lor c_j)\ \land\ (p_{2k+1} \lor \neg c_j).
\end{aligned}
\]


Каждый $c_j$ принимает фиксированное значение, добавляем единичную клаузу: $(c_j)$ для $c_j{=}1$ или $(\neg c_j)$ для $c_j{=}0$.

Введем ограничения на значения e, wt(e) = t. 
\[
\sum_{i=0}^{n} e_i \le t
\quad\text{и}\quad
\sum_{i=0}^{n} (1-e_i) \le (n{+}1 - t),
\]

что эквивалентно \(\sum e_i \ge t\).
Первое — «не больше t единиц», второе — «не больше \(n{+}1{-}t\) нулей».
Оба ограничения кодируем \emph{последовательным счётчиком} (Sinz).

\paragraph{1) Ограничение \(\sum e_i \le t\) (Sinz).}
Вводим вспомогательные переменные \(s_{i,j}\) для \(i=0,\ldots,n-1\), \(j=1,\ldots,t\).
Семантика: в первых \(i{+}1\) переменных набралось \(\ge j\) единиц.
КНФ:
\[
\begin{aligned}
\mathrm{SC}_{\le t}(e)\ \equiv\ 
&\bigwedge_{i=0}^{n-1} (\neg e_i \lor s_{i,1})
\\
&\land\ \bigwedge_{i=1}^{n-1} (\neg s_{i-1,1} \lor s_{i,1})
\\
&\land\ \bigwedge_{i=1}^{n-1}\ \bigwedge_{j=2}^{t}
\Big[\,(\neg s_{i-1,j} \lor s_{i,j}) \ \land\ (\neg e_i \lor \neg s_{i-1,j-1} \lor s_{i,j})\,\Big]
\\
&\land\ (\neg e_n \lor \neg s_{n-1,t}).
\end{aligned}
\]

\paragraph{2) Ограничение \(\sum (1-e_i) \le n{+}1{-}t\).}
Обозначим \(R:=n{+}1{-}t\).
Если \(R=0\), то просто добавляем \((e_0)\land\cdots\land(e_n)\).
Иначе вводим переменные \(q_{i,j}\) для \(i=0,\ldots,n-1\), \(j=1,\ldots,R\) (аналогично \(s\), но для нулей).
КНФ (получается из предыдущего правила подстановкой \(x_i:=\neg e_i\)):
\[
\begin{aligned}
\mathrm{SC}_{\le R}(\neg e)\ \equiv\ 
&\bigwedge_{i=0}^{n-1} (e_i \lor q_{i,1})
\\
&\land\ \bigwedge_{i=1}^{n-1} (\neg q_{i-1,1} \lor q_{i,1})
\\
&\land\ \bigwedge_{i=1}^{n-1}\ \bigwedge_{j=2}^{R}
\Big[\,(\neg q_{i-1,j} \lor q_{i,j}) \ \land\ (e_i \lor \neg q_{i-1,j-1} \lor q_{i,j})\,\Big]
\\
&\land\ (e_n \lor \neg q_{n-1,R}).
\end{aligned}
\]

\paragraph{Итоговая КНФ}



% Требуется: \usepackage{amsmath}
\[
\begin{aligned}
& \bigwedge_{i=0}^{k}
  \Big[(\neg m_i \lor \neg g_{ji} \lor \ell_i)\ \land\ (m_i \lor \neg \ell_i)\ \land\ (g_{ji} \lor \neg \ell_i)\Big]
  \land (\neg a_0 \lor p_0) \land (a_0 \lor \neg p_0) \land
\\
& \land\ \bigwedge_{r=1}^{2k+1}\ \Phi(p_r;\,p_{r-1},a_r)
  \land (\neg p_{2k+1} \lor c_j) \land (p_{2k+1} \lor \neg c_j)\lor
\\
& \lor\ \bigwedge_{i=0}^{n-1} (e_i \lor q_{i,1})
  \land\ \bigwedge_{i=1}^{n-1} (\neg q_{i-1,1} \lor q_{i,1})\land
\\
& \land\ \bigwedge_{i=1}^{n-1}\ \bigwedge_{j=2}^{R}
  \Big[(\neg q_{i-1,j} \lor q_{i,j}) \ \land\ (e_i \lor \neg q_{i-1,j-1} \lor q_{i,j})\Big]
  \land\ (e_n \lor \neg q_{n-1,R}) .
\end{aligned}
\]


Таким образом можно привести шифротекст для дальнейшего использования в кгф


% Пограничные случаи:
% - t=0: добавить (¬e_0) ∧ ... ∧ (¬e_n).
% - t=n+1: добавить (e_0) ∧ ... ∧ (e_n).



