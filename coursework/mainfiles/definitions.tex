
% ----- В тексте работы:
\section{Термины и определения}





\begin{enumerate}

\item \label{def:code}
\textbf{Код (кодовое множество).}
Кодом называется подмножество \(C \subseteq \mathbb{F}_q^n\),
состоящее из векторов длины \(n\), называемых \emph{кодовыми словами}.
Коды используются для обнаружения и исправления ошибок при передаче данных по каналу с помехами.
Если \(C\) образует линейное подпространство пространства \(\mathbb{F}_q^n\),
такой код называется \emph{линейным} и описывается своими параметрами \([n,k,d]_q\),
где \(n\) — длина кодового слова, \(k\) — размерность кода,
а \(d\) — минимальное расстояние между различными кодовыми словами(минимальный вес ненулевого кодового слова).
Такой код корректирует до \(t=\lfloor(d-1)/2\rfloor\) ошибок,
то есть любое слово, искажённое не более чем в \(t\) позициях,
может быть однозначно декодировано обратно в исходное кодовое слово,
поскольку шары Хэмминга радиуса \(t\) вокруг различных кодовых слов не пересекаются.
~\cite{MacWilliamsSloane1977,HuffmanPless2003}

~\cite{MacWilliamsSloane1977,HuffmanPless2003,vanLint1999}



\item \label{def:G}
\textbf{Порождающая матрица \(G\).}
Матрица \(k\times n\), строки которой образуют базис кода \(C\); кодовое слово \(w\) получается как \(w=sG\) для \(s\in\mathbb{F}_q^k\)~\cite{HuffmanPless2003}.

\item \label{def:H}
\textbf{Проверочная (паритетная) матрица \(H\).}
Матрица, ядро которой есть код \(C\); для всех \(c\in C\) выполнено \(Hc^{\mathsf T}=0\)~\cite{MacWilliamsSloane1977,HuffmanPless2003}.

\item \label{def:syndrome}
\textbf{Синдром.}
Для полученного слова \(y\in\mathbb{F}_q^n\) синдромом называют \(s=Hy^{\mathsf T}\in\mathbb{F}_q^{n-k}\). Синдром одинаков для всех слов одного косета и используется при декодировании~\cite{HuffmanPless2003}.

\item \label{def:hamming}
\textbf{Расстояние Хэмминга и вес.}
\(d_H(x,y)\) — число позиций, в которых \(x\) и \(y\) различаются; \(\mathrm{wt}(x)=d_H(x,0)\) — вес вектора~\cite{vanLint1999,HuffmanPless2003}.

\item \label{def:gf}
\textbf{Конечное поле \(\mathbb{F}_q\) (поле Галуа).}
Поле мощности \(q=p^m\) (степень простого \(p\)); все поля данного порядка изоморфны~\cite{LidlNiederreiter1997}.

\item \label{def:goppa}
\textbf{Двоичный код Гоппы \(\Gamma(g,L)\).}
Код над \(\mathbb{F}_{2}\), задаваемый неприводимым \(g(x)\in\mathbb{F}_{2^m}[x]\) степени \(t\) и набором локаторов \(L=\{\alpha_i\}\subset\mathbb{F}_{2^m}\), где \(g(\alpha_i)\neq 0\)~\cite{Goppa1970}.

\item \label{def:locator}
\textbf{Локаторы (locator set).}
Набор попарно различных элементов поля \(L=\{\alpha_1,\dots,\alpha_n\}\subset\mathbb{F}_{2^m}\), для которых \(g(\alpha_i)\neq 0\).
Каждый локатор \(\alpha_i\) однозначно соответствует \(i\)-й координате кодового слова и определяет столбец проверочной матрицы кода Гоппы.
Стандартный вид \(H\) задаётся по локаторам как
\[
H \;=\;
\begin{bmatrix}
\frac{1}{g(\alpha_1)} & \frac{1}{g(\alpha_2)} & \cdots & \frac{1}{g(\alpha_n)} \\
\frac{\alpha_1}{g(\alpha_1)} & \frac{\alpha_2}{g(\alpha_2)} & \cdots & \frac{\alpha_n}{g(\alpha_n)} \\
\vdots & \vdots & \ddots & \vdots \\
\frac{\alpha_1^{t-1}}{g(\alpha_1)} & \frac{\alpha_2^{t-1}}{g(\alpha_2)} & \cdots & \frac{\alpha_n^{t-1}}
{g(\alpha_n)}
\end{bmatrix},
\]
где \(g(x)\in\mathbb{F}_{2^m}[x]\) — неприводимый многочлен степени \(t\).

~\cite{HuffmanPless2003,CMspec2022}


\item \label{def:patterson}
\textbf{Алгоритм Паттерсона.}
Полиномиальный алгоритм декодирования классических двоичных кодов Гоппы, исправляющий до \(t\) ошибок~\cite{Patterson1975}.

\item \label{def:perm}
\textbf{Матрица перестановки \(P\).}
Квадратная бинарная матрица с ровно одной единицей в каждой строке и каждом столбце; задаёт перестановку координат, \(P^{-1}=P^{\mathsf T}\)~\cite{HornJohnson2013}.

\item \label{def:scrambler}
\textbf{«Скрэмблирующая» матрица \(S\).}
Невырожденная матрица (обычно \(k\times k\)), применяемая для маскирования структуры выбранного кода в открытом ключе схемы Мак–Элиса; классически \(G_{\text{pub}}=SGP\)~\cite{McEliece1978}.

\item \label{def:mceliece}
\textbf{Криптосистема Мак–Элиса.}
Асимметричная схема (1978) на основе корректирующих кодов: публикуется «замаскированный» линейный код с эффективным секретным декодером; при шифровании добавляется случайный вектор ошибки ограниченного веса~\cite{McEliece1978}.

\item \label{def:np}
\textbf{NP\,-трудность декодирования общего линейного кода.}
Задача синдромного ML‑декодирования линейных кодов для случайной матрицы \(H\) является NP‑трудной (NP‑полной в решающей постановке)~\cite{BMvT1978}.

\item \label{def:isd}
\textbf{ISD-алгоритмы (Information-Set Decoding).}
Класс вероятностных алгоритмов декодирования случайных линейных кодов без знания их структуры.
Основная идея заключается в выборе случайного подмножества координат — \emph{информационного множества} —
в котором предполагается отсутствие ошибок.
Если выбранные позиции действительно свободны от ошибок, задача восстановления исходного информационного вектора
решается системой линейных уравнений по выбранным координатам.
Повторяя выбор множества и проверку синдрома, алгоритм находит вектор ошибки заданного веса.
Методы этого типа (начиная с алгоритма Пратта–Берлекэмпа–Мессси–Тильборга) 
лежат в основе оценки стойкости код-базированных криптосистем,
включая схему Мак-Элиса и её варианты.
~\cite{Prange1962,Dumer1991,MayMeurerThomae2011,BernsteinLangePeters2011}


\item \label{def:niederreiter}
\textbf{Вариант Нидеррайтера.}
Двойственная к Мак–Элису схема (1986), использующая проверочную матрицу; шифротекстом служит синдром \(s=H_{\text{pub}}e^{\mathsf T}\)~\cite{Niederreiter1986}.

\item \label{def:kem}
\textbf{Механизм инкапсуляции ключа (KEM).}
Абстракция из гибридного шифрования с тремя алгоритмами \(\textsf{KeyGen/Encap/Decap}\) (композиция с DEM образует PKE); формализована в работах Shoup/Cramer–Shoup и в последующих развёрнутых анализах~\cite{ShoupISO2001,CramerShoup2003,AbeTagKEM2005}.

\item \label{def:cm}
\textbf{Classic McEliece (CM).}
Консервативный код‑базированный KEM на двоичных кодах Гоппы и варианте Нидеррайтера; спецификация задаёт \(\textsf{KeyGen/Encap/Decap}\), форматы ключей/шифртекста и наборы параметров~\cite{CMspec2022,NISTIR8413}.

\item \label{def:cmsyndrome}
\textbf{Синдром в CM.}
В CM шифртекст фактически является синдромом по публичной проверочной матрице; при деккапсуляции восстанавливается вектор ошибки веса \(t\)~\cite{CMspec2022}.

\item \label{def:syndec}
\textbf{Синдромное декодирование (обобщённо).}
Декодирование по синдрому \(s=Hy^{\mathsf T}\) с выбором лидера косета минимального веса как оценки вектора ошибки~\cite{HuffmanPless2003}.

\item \label{def:vander}
\textbf{Матрица Вандермонда (для справки).}
Матрица \(V=(x_i^{\,j})\) имеет определитель \(\prod_{i<j}(x_j-x_i)\); при попарной различимости узлов невырождена~\cite{HornJohnson2013}.

\item \label{def:params}
\textbf{Параметры \((n,k,t,m,q)\) (нотация CM).}
\(n\) — длина кода; \(k\) — размерность; \(t\) — исправляемость; \(q=2^m\); \(m=\log_2 q\) — согласно спецификации CM~\cite{CMspec2022}.

\item \label{def:notation}
\textbf{Обозначения.}
\(\mathbb{F}_q\) — конечное поле; \(\mathbb{F}_2^n\) — двоичные векторы длины \(n\); \(\mathrm{wt}(\cdot)\) — вес Хэмминга; \(I_r\) — единичная матрица; \(0\) — нулевой вектор/матрица; \(\perp\) — «отказ»~\cite{LidlNiederreiter1997,CMspec2022,HuffmanPless2003}.
\end{enumerate}

% Рекомендуется иметь в преамбуле:
% \usepackage{amsmath,amssymb}
% \usepackage[russian]{babel}
% \usepackage{enumitem}




\begin{enumerate}[

\item \label{defsat:sat}
\textbf{Задача булевой выполнимости (SAT).}
Проблема принятия решения: существует ли такое присваивание булевых переменных, которое удовлетворяет всем клаузам формулы (обычно в CNF). SAT является NP-полной задачей.~\cite{Cook1971,HandbookSAT2021}

\item \label{defsat:cnf}
\textbf{Переменная, литерал, клауза, CNF.}
Пусть \(x_1,\dots,x_n\) — булевы переменные (\(x_i\in\{0,1\}\)).
Литерал — это переменная или её отрицание:
\[
\mathrm{Lit}(x_i)=\{\,x_i,\ \lnot x_i\,\},\qquad
\mathrm{Lit}=\bigcup_{i=1}^n \mathrm{Lit}(x_i).
\]
Клауза — дизъюнкция литералов:
\[
C=\ell_1\lor\ell_2\lor\cdots\lor\ell_k,\qquad \ell_p\in\mathrm{Lit}.
\]
Формула в конъюнктивной нормальной форме (CNF) — конъюнкция клауз:
\[
\varphi=\bigwedge_{j=1}^{m} C_j
=\bigwedge_{j=1}^{m}\left(\ \bigvee_{i\in I_j} x_i\ \ \lor\ \ \bigvee_{i\in J_j} \lnot x_i\ \right),
\quad I_j\cap J_j=\varnothing.
\]
Семантика удовлетворимости через присваивание \(\alpha:\{x_1,\dots,x_n\}\to\{0,1\}\):
\[
v_\alpha(x_i)=\alpha(x_i),\qquad v_\alpha(\lnot x_i)=1-\alpha(x_i),
\]
\[
\alpha\models C\iff \sum_{p=1}^{k} v_\alpha(\ell_p)\ge 1,
\qquad
\alpha\models \varphi\iff \forall j\in\{1,\dots,m\}\ \ (\alpha\models C_j).
\]
(Пустая клауза \(\square\) — ложь; пустая конъюнкция \(\top\) — истина.)
~\cite{HandbookSAT2021}

\item \label{defsat:xor}
\textbf{XOR‑ограничение (линейное равенство над \(\mathbb{F}_2\)).}
Ограничение вида \(x_1 \oplus \cdots \oplus x_m = b\), \(b\in\{0,1\}\).
Поддерживается рядом решателей напрямую либо компилируется в CNF.~\cite{SoosNohlCastelluccia2009,HandbookSAT2021}

\item \label{defsat:tseitin}
\textbf{Преобразование Цейтина.}
Полиномиальное преобразование произвольной булевой формулы \(\varphi\) в CNF \(\mathrm{T}(\varphi)\) с линейным ростом размера.
Формулы \(\varphi\) и \(\mathrm{T}(\varphi)\land p_\varphi\) \emph{эквисатисфактабельны}, т.е.
\[
(\exists\,\alpha\;\alpha\models\varphi)\ \Longleftrightarrow\ (\exists\,\beta\;\beta\models \mathrm{T}(\varphi)\land p_\varphi),
\]
где \(p_\varphi\) — новая «корневая» переменная, обозначающая значение \(\varphi\).
Эквисатисфактабельность означает совпадение факта выполнимости/невыполнимости (это слабее логической эквивалентности; множества моделей могут различаться).
Построение выполняется путём введения вспомогательных переменных для подформул и добавления клауз, связывающих их значения.
~\cite{Tseitin1983,HandbookSAT2021}

\item \label{defsat:pb}
\textbf{Псевдобулевые (PB) и кардинальные ограничения.}
PB‑ограничения имеют вид \(\sum_i w_i x_i \le t\) для целых \(w_i,t\).
Кардинальные — частный случай с \(w_i=1\), типа \(\sum_i x_i = t\) или \(\le t\).
В CNF кодируются специализированными энкодингами.~\cite{EenSorensson2006,HandbookSAT2021}

\item \label{defsat:seq}
\textbf{Последовательный счётчик (Sequential counter).}
CNF‑энкодинг кардинальных ограничений с сильным unit‑propagation и умеренным размером при типичных \((n,t)\).~\cite{Sinz2005}

\item \label{defsat:totalizer}
\textbf{Тотализатор (Totalizer).}
Иерархическая схема суммирования единиц с хорошим распространением единиц и эффективной поддержкой \(\le t\).~\cite{BailleuxBoufkhad2003}

\item \label{defsat:adder}
\textbf{Аддерные/бинарные энкодинги.}
Кодировки, основанные на двоичном сложении (half/full‑adders), удобны для инкрементального SAT и смешанных PB‑ограничений.~\cite{EenSorensson2006}

\item \label{defsat:cardnet}
\textbf{Сортировочные/кардинальные сети.}
Сетевые энкодинги (на основе сортировочных сетей) дают предсказуемое поведение и сильную пропагацию, полезны при больших \(n\).~\cite{Asin2009}

\item \label{defsat:up}
\textbf{Единичное распространение (Unit propagation).}
Итеративное назначение литералов, принуждаемое унарными клаузами; в современных решателях эффективно реализуется через двухсторожевые литералы.~\cite{Moskewicz2001,HandbookSAT2021}

\item \label{defsat:cdcl}
\textbf{CDCL‑решатели.}
Современная парадигма решения SAT: анализ конфликтов, обучение (learning) новых клауз, не‑хронологический откат, активные рестарты.~\cite{MarquesSilvaSakallah1999,HandbookSAT2021}

\item \label{defsat:vsids}
\textbf{Эвристики ветвления (напр., VSIDS).}
Оценка активности литералов по встречаемости в конфликтах; определяет порядок выбора ветвления.~\cite{Moskewicz2001}

\item \label{defsat:phase}
\textbf{Выбор фаз (phase selection).}
Стратегии задания начального знака литерала при ветвлении (напр., сохранение последней фазы), влияющие на глубину поиска.~\cite{EenSorensson2003}

\item \label{defsat:restarts}
\textbf{Рестарты.}
Периодический перезапуск поиска с сохранением выученных клауз для обхода «трудных» областей пространства.~\cite{GomesSelmanKautz1998}

\item \label{defsat:vivif}
\textbf{Вивификация клауз и \emph{inprocessing}.}
Усильнение клауз (сокращение/ужесточение) и упрощение формулы в ходе решения (а не только до него).~\cite{JarvisaloHeuleBiere2012}

\item \label{defsat:preproc}
\textbf{Предобработка (preprocessing).}
Выбрасывание доминируемых клауз, самоподстановочная резолюция, устранение переменных, заблокированные клаузы и др. (напр., SatELite).~\cite{EenBiere2005}

\item \label{defsat:xorgauss}
\textbf{SAT+XOR и «на лету» исключение Гаусса.}
Интеграция линейной алгебры над \(\mathbb{F}_2\) в SAT‑решатель (выделенные XOR‑ядра, гауссово исключение), существенно ускоряющая крипто‑инстансы.~\cite{SoosNohlCastelluccia2009}

\item \label{defsat:incr}
\textbf{Инкрементальный SAT.}
Повторное решение близких инстансов с сохранением базы клауз/активностей (API уровня \(\operatorname{assumptions}\)).~\cite{EenSorensson2003}

\item \label{defsat:backbone}
\textbf{Хребет (backbone).}
Множество литералов, принимающих одно и то же значение во всех удовлетворяющих присваиваниях; измеряет «жёсткость» формулы.~\cite{HandbookSAT2021}

\item \label{defsat:sbox}
\textbf{CNF‑кодирование нелинейностей (S‑блоков).}
Представление таблично заданных функций (S‑блоков) в виде компактных CNF‑сетей с оптимизацией числа клауз/переменных.~\cite{HandbookSAT2021}

\end{enumerate}





